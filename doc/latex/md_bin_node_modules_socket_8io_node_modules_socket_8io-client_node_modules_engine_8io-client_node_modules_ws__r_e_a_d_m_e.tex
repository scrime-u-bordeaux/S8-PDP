\href{https://www.npmjs.com/package/ws}{\tt } \href{https://travis-ci.org/websockets/ws}{\tt } \href{https://ci.appveyor.com/project/lpinca/ws}{\tt } \href{https://coveralls.io/r/websockets/ws?branch=master}{\tt }

{\ttfamily ws} is a simple to use, blazing fast, and thoroughly tested Web\+Socket client and server implementation.

Passes the quite extensive Autobahn test suite. See \href{http://websockets.github.io/ws/}{\tt http\+://websockets.\+github.\+io/ws/} for the full reports.

{\bfseries Note}\+: This module does not work in the browser. The client in the docs is a reference to a back end with the role of a client in the Web\+Socket communication. Browser clients must use the native \href{https://developer.mozilla.org/en-US/docs/Web/API/WebSocket}{\tt {\ttfamily Web\+Socket}} object.

\subsection*{Protocol support}


\begin{DoxyItemize}
\item {\bfseries Hy\+Bi drafts 07-\/12} (Use the option {\ttfamily protocol\+Version\+: 8})
\item {\bfseries Hy\+Bi drafts 13-\/17} (Current default, alternatively option {\ttfamily protocol\+Version\+: 13})
\end{DoxyItemize}

\subsection*{Installing}


\begin{DoxyCode}
npm install --save ws
\end{DoxyCode}


\subsubsection*{Opt-\/in for performance and spec compliance}

There are 2 optional modules that can be installed along side with the {\ttfamily ws} module. These modules are binary addons which improve certain operations. Prebuilt binaries are available for the most popular platforms so you don\textquotesingle{}t necessarily need to have a C++ compiler installed on your machine.


\begin{DoxyItemize}
\item {\ttfamily npm install -\/-\/save-\/optional bufferutil}\+: Allows to efficiently perform operations such as masking and unmasking the data payload of the Web\+Socket frames.
\item {\ttfamily npm install -\/-\/save-\/optional utf-\/8-\/validate}\+: Allows to efficiently check if a message contains valid U\+T\+F-\/8 as required by the spec.
\end{DoxyItemize}

\subsection*{A\+PI Docs}

See https\+://github.com/websockets/ws/blob/master/doc/ws.\+md \char`\"{}\`{}/doc/ws.\+md\`{}\char`\"{} for Node.\+js-\/like docs for the ws classes.

\subsection*{Web\+Socket compression}

{\ttfamily ws} supports the \href{https://tools.ietf.org/html/rfc7692}{\tt permessage-\/deflate extension} which enables the client and server to negotiate a compression algorithm and its parameters, and then selectively apply it to the data payloads of each Web\+Socket message.

The extension is enabled by default but adds a significant overhead in terms of performance and memory comsumption. We suggest to use Web\+Socket compression only if it is really needed.

To disable the extension you can set the {\ttfamily per\+Message\+Deflate} option to {\ttfamily false}. On the server\+:


\begin{DoxyCode}
const WebSocket = require('ws');

const wss = new WebSocket.Server(\{
  perMessageDeflate: false,
  port: 8080
\});
\end{DoxyCode}


On the client\+:


\begin{DoxyCode}
const WebSocket = require('ws');

const ws = new WebSocket('ws://www.host.com/path', \{
  perMessageDeflate: false
\});
\end{DoxyCode}


\subsection*{Usage examples}

\subsubsection*{Sending and receiving text data}


\begin{DoxyCode}
const WebSocket = require('ws');

const ws = new WebSocket('ws://www.host.com/path');

ws.on('open', function open() \{
  ws.send('something');
\});

ws.on('message', function incoming(data, flags) \{
  // flags.binary will be set if a binary data is received.
  // flags.masked will be set if the data was masked.
\});
\end{DoxyCode}


\subsubsection*{Sending binary data}


\begin{DoxyCode}
const WebSocket = require('ws');

const ws = new WebSocket('ws://www.host.com/path');

ws.on('open', function open() \{
  const array = new Float32Array(5);

  for (var i = 0; i < array.length; ++i) \{
    array[i] = i / 2;
  \}

  ws.send(array);
\});
\end{DoxyCode}


\subsubsection*{Server example}


\begin{DoxyCode}
const WebSocket = require('ws');

const wss = new WebSocket.Server(\{ port: 8080 \});

wss.on('connection', function connection(ws) \{
  ws.on('message', function incoming(message) \{
    console.log('received: %s', message);
  \});

  ws.send('something');
\});
\end{DoxyCode}


\subsubsection*{Broadcast example}


\begin{DoxyCode}
const WebSocket = require('ws');

const wss = new WebSocket.Server(\{ port: 8080 \});

// Broadcast to all.
wss.broadcast = function broadcast(data) \{
  wss.clients.forEach(function each(client) \{
    if (client.readyState === WebSocket.OPEN) \{
      client.send(data);
    \}
  \});
\};

wss.on('connection', function connection(ws) \{
  ws.on('message', function incoming(data) \{
    // Broadcast to everyone else.
    wss.clients.forEach(function each(client) \{
      if (client !== ws && client.readyState === WebSocket.OPEN) \{
        client.send(data);
      \}
    \});
  \});
\});
\end{DoxyCode}


\subsubsection*{Express\+JS example}


\begin{DoxyCode}
const express = require('express');
const http = require('http');
const url = require('url');
const WebSocket = require('ws');

const app = express();

app.use(function (req, res) \{
  res.send(\{ msg: "hello" \});
\});

const server = http.createServer(app);
const wss = new WebSocket.Server(\{ server \});

wss.on('connection', function connection(ws) \{
  const location = url.parse(ws.upgradeReq.url, true);
  // You might use location.query.access\_token to authenticate or share sessions
  // or ws.upgradeReq.headers.cookie (see http://stackoverflow.com/a/16395220/151312)

  ws.on('message', function incoming(message) \{
    console.log('received: %s', message);
  \});

  ws.send('something');
\});

server.listen(8080, function listening() \{
  console.log('Listening on %d', server.address().port);
\});
\end{DoxyCode}


\subsubsection*{echo.\+websocket.\+org demo}


\begin{DoxyCode}
const WebSocket = require('ws');

const ws = new WebSocket('wss://echo.websocket.org/', \{
  origin: 'https://websocket.org'
\});

ws.on('open', function open() \{
  console.log('connected');
  ws.send(Date.now());
\});

ws.on('close', function close() \{
  console.log('disconnected');
\});

ws.on('message', function incoming(data, flags) \{
  console.log(`Roundtrip time: $\{Date.now() - data\} ms`, flags);

  setTimeout(function timeout() \{
    ws.send(Date.now());
  \}, 500);
\});
\end{DoxyCode}


\subsubsection*{Other examples}

For a full example with a browser client communicating with a ws server, see the examples folder.

Otherwise, see the test cases.

\subsection*{Error handling best practices}


\begin{DoxyCode}
// If the WebSocket is closed before the following send is attempted
ws.send('something');

// Errors (both immediate and async write errors) can be detected in an optional
// callback. The callback is also the only way of being notified that data has
// actually been sent.
ws.send('something', function ack(error) \{
  // If error is not defined, the send has been completed, otherwise the error
  // object will indicate what failed.
\});

// Immediate errors can also be handled with `try...catch`, but **note** that
// since sends are inherently asynchronous, socket write failures will *not* be
// captured when this technique is used.
try \{ ws.send('something'); \}
catch (e) \{ /* handle error */ \}
\end{DoxyCode}


\subsection*{Changelog}

We\textquotesingle{}re using the Git\+Hub \href{https://github.com/websockets/ws/releases}{\tt {\ttfamily releases}} for changelog entries.

\subsection*{License}

\mbox{[}M\+IT\mbox{]}(L\+I\+C\+E\+N\+SE) 