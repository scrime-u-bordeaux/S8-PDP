\section{Refactoring et révision de l'interface graphique}

\subsection{Révisions générales sur le code}
\paragraph{}
Nous avons rapidement établi que le refactoring du code existant
faisait partie des besoins de notre projet. Dans cette partie, nous
décrirons l'ensemble des travaux réalisés dans ce cadre.

\subsubsection{Conventions de programmation et assistance au programmeur}
\paragraph{}
L'un des premiers reproches faits par l'équipe pédagogique à
l'architecture héritée de Jérémy Lixandre est son manque de clarté ;
le code livré était trop peu commenté pour permettre à un programmeur
de comprendre ne serait-ce que le rôle de chaque classe sans rentrer
en détail dans l'intégralité de leur code. Pour cette raison, nous
avons ajouté des commentaires d'en-tête à chaque début de fichier
\verb!.cpp! afin d'expliquer le rôle de chacun de ces fichiers.
\paragraph{}
Des commentaires ont également été ajoutés massivement au niveau des
fonctions principales du programme. En effet, la compréhension du
programme existant a considérablement ralenti le démarrage de notre
implémentation sur ce projet, et a nécessité plusieurs recherches sur
le web et la consultation conjointe de divers documents de sources
différentes. Les deux fichiers ayant été les plus commentés de la
sorte sont \verb!main.cpp! et \verb!render.cpp!.
\paragraph{}
La syntaxe du code a été remodelée de manière générale pour répondre à
des conventions autant que pour faciliter sa compréhension : les
"include" en début de fichiers ont été classés selon le type de
fichiers inclus et par ordre alphabétique, la langue des commentaires
a été uniformisée, les indentations, choix de placement de
crochets/accolades etc. ont été uniformisés également pour une
meilleure cohérence de la syntaxe, les variables ont été renommées
pour être plus claires et éviter de heurter les conventions qui nous
ont été enseignées.

\subsubsection{Modification de l'architecture logicielle}
\paragraph{}
D'autres approches du code réalisées par Jérémy Lixandre nous
semblaient maladroites. Afin de rendre une architecture répondant au
mieux aux conventions de programmation vues en cours et qui soit la
plus compréhensible et claire possible aux yeux d'un potentiel futur
programmeur, nous avons apporté plusieurs révisions liées à
l'organisation des fichiers.
\begin{itemize}
  \item Le code de \verb!main.cpp! a été entièrement révisé. En effet,
    il contenait une unique fonction
    \verb!main(int argc, char *argv[])! qui nous paraissait bien trop
    dense. Afin de faciliter la compréhension du lecteur et de mieux
    correspondre aux conventions, nous avons effectué un découpage
    fonctionnel de cette fonction en plusieurs fonctions. La fonction
    \verb!main! appelle une fonction
    \verb!launch(int argc, char *argv[])! qui elle-même appelle
    d'autres fonctions (lesquelles, parfois, en appellent elles-mêmes
    de nouvelles).

    \begin{lstlisting}
      static void launch(int argc, char *argv[]){
        ChSettings gChSettings;
        Parser config;
        void *handle;
        ProcessMultiCorrel *p;
        config = initParser(argc, argv);
        handle = initHandler();
        p = initProcessMultiCorrel(handle);
        setupSettings(gChSettings, config, p, handle);
        initAndRun(gChSettings, config, argv);
        stopAndCleanupAudio();
        freeAndClose(gChSettings, config, p, handle);
      }
    \end{lstlisting}

    \begin{center}
      \textit{Ci-dessus, le code de la fonction launch}
    \end{center}    

    \item Nous avons de même effectué un découpage fonctionnel sur la
      fonction \verb!setup(BelaContext *context, void *userData)! du
      fichier \verb!render.cpp!. Ce dernier, qui présentait tout comme
      \verb!main.cpp! une organisation assez confuse, ne pouvait pas
      cependant être remanié autant en profondeur que le code
      précédemment abordé. En effet, la fonction principale du
      fichier,
      \verb!void render(BelaContext * context, void *userData)!, ne
      pouvait être découpée de manière maintenable. En effet, elle
      exécute une boucle de traitement audio, en créant des taches
      auxiliaires exécutées par d'autres threads pour garantir un
      traitement rapide (qui doit être au minimum plus rapide que la
      vitesse de lecture des pistes), et il n'était pas possible de la
      découper sans créer de conflits sur les variables enregistrant
      le nombre de tours de boucle ou les variables contenant les
      signaux audio par exemple.

      \begin{lstlisting}
      bool setup(BelaContext *context, void *userData) {
        gUserSet = *((ChSettings *)userData);
        initUserSet(gUserSet);
        initBuffers();
        initSampleStreams(gUserSet);
        printInfo();
        return initAuxiliaryTasks();
      }
    \end{lstlisting}

    \begin{center}
      \textit{Ci-dessus, le code de la fonction setup}
    \end{center}    

      \item \`{A} l'intérieur du dossier \verb!process!, les
        différents fichiers de traitement ont été classés par
        fonctions en quatre dossiers \verb!Coeff!, \verb!Color!,
        \verb!Preproc! et \verb!Mix!. \`{A} l'intérieur du dossier
        \verb!test!, les fichiers que nous avons implémenté pour tester les
        différentes fonctions du programme ont été classés de la même
        manière (Jérémy Lixandre n'avait pour sa part pas implémenté
        de fichiers de test).

        \item D'une manière générale, les fichiers ont été triés pour
          ordonner l'architecture proposée par Jérémy qui était un peu
          confuse ; des fichiers de code n'ayant rien à voir entre eux
          se côtoyaient au sein d'un même dossier, et l'architecture
          présentait une hiérarchie n'étant pas toujours en rapport
          avec celle que présente le logiciel. Pour ces raisons, nous
          avons partagé les fichiers en plusieurs sous-dossiers,
          notamment les fichiers sources et les fichiers d'en-tête au
          sein du dossier \verb!VisualImpro!, et nous avons modifié
          les fichiers Makefile en conséquence. Le fichier de
          configuration \verb!config.cfg! a notamment été déplacé dans
          un nouveau dossier \verb!bin!.

          \item Dans le code livré par Jérémy Lixandre, un dossier
            \verb!VisualImproExe! regroupait un fichier de
            configurations, les fichiers relatifs à NodeJS, un fichier
            html lié à l'affichage de la matrice graphique via le
            navigateur Mozilla Firefox et les fichiers sources C++
            permettant les manipulations nécessaires au lancement du
            programme VisualImpro : mises à jour du fichier de
            configuration, transmission de fichiers vers Bela. Nous
            avons supprimé ce dossier puisqu'il rassemblait des
            éléments n'ayant aucun lien entre eux. Le dossier
            \verb!bin! que nous avons créé a hérité d'un script bash
            \verb!VisualImpro.sh! et des fichiers nécessaires à son
            exécution, tels les fichiers audios de test.
\end{itemize}
\paragraph{}
%fais le BASH GROS BATAR

\subsubsection{Optimisation du code}
\paragraph{}
Afin de garantir un traitement rapide des informations par BELA et de
produire un retour sonore sans risque de latence, nous avons dû
optimiser certaines parties du code. Dans son rapport, Jérémy Lixandre
avait précisé que le traitement de BELA occupait une part trop
importante du CPU à partir de quinze fichiers \verb!.wav! traités
simultanément ; ce constat nous a encouragés à optimiser le programme
pour limiter le coût de son exécution.
\paragraph{}
L'implémentation de l'existant présentait notamment de nombreuses
copies des matrices passées en paramètres. Ces matrices sont des
éléments particulièrement lourds, contenant un nombre de données égal
au produit du nombre de pistes sonores en entrée par 32768 (taille des
buffers traités). Nous avons choisi de remplacer ces copies
successives de matrices par le placement en paramètres de références
constantes de ces matrices.

\begin{lstlisting}
void ProcessMultiCorrel::process(const Matrix<float>& buffer,
                                 vector<float>& meanCorrelations,
                                 Connection conn){
  Matrix<float> copy = buffer;

  // Processing functions
  copy = _preprocess(buffer);
  Matrix<float> correlMatrix = calcul_correl(copy);
  process_volume(correlMatrix, meanCorrelations);
  Matrix<RGB> mat = color_matrix(correlMatrix);

  // Send data
  string str = mat.toString();
  conn.send(str);
}
\end{lstlisting}
\begin{center}
  \textit{Ci-dessus, la fonction principale de
    \verb!ProcessMultiCorrel.cpp!. Son code témoigne de multiples
    opérations de refactoring et d'optimisations du code ; en effet,
    le nombre d'appels de fonctions auxiliaires témoigne du découpage
    fonctionnel de la fonction d'origine, laquelle était autrement
    plus dense. De plus, on peut observer dans les paramètres qu'une
    matrice des moyennes de coefficients de corrélation a été ajoutée
    pour permettre l'implémentation du mixage du retour sonore. Enfin,
    la matrice de flottants "buffer" a été changée en sa référence
    constante, afin d'éviter d'avoir à en faire une copie dans le
    corps de la fonction.}
  \end{center}


\subsection{Les changements apportés à l'interface graphique}
\paragraph{}
Précédemment, nous parlions de la nécessité de modifier l'affichage de
l'interface graphique pour diverses raisons. Nos clients n'exprimaient
pas de préférence quant à la méthode employée pour afficher la matrice
imaginée par nos prédécesseurs de l'ENSEIRB, mais nous trouvions peu
judicieux et coûteux pour le programme de passer par NodeJS et Mozilla
Firefox pour la produire. Un affichage graphique implémenté en C++
grâce au framework Qt nous paraissait plus logique, judicieux et
conforme au reste de l'architecture de notre programme.
\paragraph{}
Cependant, nous pouvons reconnaître l'avantage que peut avoir
l'affichage de la matrice sur un navigateur répandu comme Mozilla
Firefox. En effet, on peut imaginer qu'à l'avenir, le programme
embarqué sur le système Bela pourra se passer d'un ordinateur pour
fonctionner et afficher la matrice sur l'écran d'un smartphone par
exemple en passant par un navigateur web. Pour cette raison, nous
avons décidé d'offrir à l'utilisateur la possibilité de choisir entre
l'affichage Qt et l'affichage sur navigateur au moment de lancer
l'exécution du programme.

\subsubsection{L'implémentation de la méthode d'affichage sous Qt}
