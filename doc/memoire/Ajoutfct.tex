\section{Ajout de fonctionnalités}

\subsection{L'implémentation du retour sonore}
\paragraph{}
Dans le programme de Jérémy Lixandre, la classe \verb!Parser! a pour
utilité de récupérer les informations du fichier de configuration
\verb!config.cfg!, notamment toutes les fonctions de
\textit{processing}. Ce fichier a donc été modifié afin de prendre en
compte notre nouvelle fonction de \textit{processing}, la fonction de
mixage, qui vient s'ajouter aux trois existantes. Tout comme ces
fonctions, elle est générique et doit pouvoir être sélectionnée par
l'utilisateur depuis un menu de configuration.

\paragraph{}
Un fichier dédié à la fonction de mixage a un nom commençant par
\verb!Mix!. Il est répertorié dans le dossier \verb!Mix! du dossier
\verb!Process!. La fonction de mixage doit prendre une matrice en
paramètre ; il s'agit de la matrice retournée par la fonction de
calcul du coefficient de corrélation. Elle retourne un vecteur de
coefficients : à un instant donné, chaque piste dispose désormais d'un
seul coefficient qui doit déterminer la façon dont elle va être
diminuée en volume sonore dans le retour audio.

\paragraph{}
Nous avons implémenté plusieurs fonctions de mixage. La fonction
\verb!vector<float>!
\\ \verb!MixMaxCorrelated!, par
exemple, renvoie un coefficient égal à la moyenne des coefficients de
corrélation de la piste avec toutes les autres pistes. Les instruments
les moins corrélés recevront ici un malus sur l'amplitude de leur signal.
Tandis que la fonction de traduction du coefficient de corrélation en
triplet RGB est dédiée uniquement au retour visuel, celle de mixage est
dédiée uniquement au retour sonore.

\begin{lstlisting}
vector<float> MixMaxCorrelated(const Matrix<float>& correlMatrix) {

  int row = correlMatrix.getSize();
  int col = correlMatrix.getRow(0).size();

  // initialize the result vector with zeros
  vector<float> meanCorrelations(row, 0.0f);

  // fill the vector with the mean correlation of
  // each instrument with others
  for (int i = 0; i < row; i++) {
    for (int j = 0; j < col; j++) {
      if (i != j)
        meanCorrelations[i] += correlMatrix.getCase(i, j);
    }
    meanCorrelations[i] /= (float)row-1;
  }

  return meanCorrelations;
}
\end{lstlisting}

\begin{center}
 \textit{Ci-dessus, l'exemple de la fonction de mixage précédemment cité}
\end{center}

\paragraph{}
Dans la fonction \verb!void parseProcessFunc!  appelée dans le fichier
\verb!main.cpp!, nous avons dû ajouter l'analyse de la fonction de
mixage sur le modèle des analyses des trois autres fonctions de
\textit{processing}.

\paragraph{}
L'architecture de Bela a été conçue pour permettre la synthèse d'un
retour sonore dans le corps de la fonction \verb!void render! du
fichier éponyme. Grâce au code implémenté par notre prédécesseur au
sein de cette fonction, Bela peut synthétiser un retour sonore modifié
par notre fonction de mixage.

\begin{lstlisting}
for(unsigned int i=0; i<context->audioOutChannels; i++){
   if(gSampleFactor == STANDARD_SAMPLE_RATE){
      audioWrite(context, 2 * n, i, out);
      audioWrite(context, 2 * n + 1, i, out);
   } else {
      audioWrite(context, n, i, out);
   }
}
\end{lstlisting}

\begin{center} \textit{Ci-dessus, l'implémentation du retour sonore
dans le corps de la fonction principale de \verb!render.cpp!. Via la
fonction \verb!audioWrite!, la variable \verb!out! récupère un à un
les signaux multipliés par la moyenne de leurs coefficients de
corrélation par rapport aux autres signaux.} \end{center}

%  - Ici c'est bien l'écriture du retour sonore, via la variable out, mais ce
 % qui est vraiment important c'est le comportement de la variable out. Elle
%  récupère les signaux un à un en les additionnant et les stockant dans sa
%  variable (c'est le cas de base), mais pour notre cas, elle récupère les
%  signaux multipliés par la moyenne de leur corrélation par rapport aux autres
%  instruments (valeur comprise entre 0 et 1). On peut voir ça dans les boucles
%  de chaque type de pistes (audio, analogique ou digitale--pour les fichiers--)%,
%  pour la boucle de traitement sans effets pour le moment.

\paragraph{}
Dans le fichier \verb!render.cpp!, la fonction
\verb!void processBuffer()! est utilisée comme tâche auxiliaire de la
boucle de traitement principale. Nous avons déclaré un vecteur
\verb!gMeanCorrel! dans \verb!render.cpp! ; initialisé avec une valeur
de 1 pour tous les indices, il prend la valeur que retourne la
fonction de mixage à l'intérieur du code de la fonction
\verb!void ProcessMultiCorrel::process!
que nous avons modifiée et qui est appelée dans \verb!processBuffer!
de \verb!render.cpp!.
\paragraph{}
Dans l'implémentation de Jérémy Lixandre, le traitement des tâches auxiliaires dnas \verb!render.cpp! se faisait à sens unique : exécution de tâches auxiliaires sans retour de valeur dans la boucle de traitement principale. Afin de récupérer le résultat du traitement de la fonction de mixage, nous avons ajouté la référence du vecteur contenant les moyennes de coefficients de corrélation, \verb!gMeanCorrel!, %A FINIR DE REDIGER

% A expliquer j'ai pas pigé le lien entre gMeanCorrel et process
  - Le traitement des tâches auxiliaires dans le render se faisant à sens
  unique (le render exécute des taches auxiliaires sans renvoyer de valeur de
  retour à la boucle de traitement principale), le moyen pour nous de récupérer
  le résultat du traitement de la fonction de mix était de passer le vecteur
  contenant les moyennes de corrélation, gMeanCorrel, par référence à la
  fonction process. On accède ainsi à la case mémoire de la variable pour
  permettre à la fonction de modifier son contenue et ainsi d'affecter les
  valeurs de retour de la fonction de mixage à notre vecteur. C'est ainsi que
  les modifications des volumes sont possibles dans notre programme.

  \begin{lstlisting}
    void ProcessMultiCorrel::process(const Matrix<float>& buffer,
                                 vector<float>& meanCorrelations,
                                 Connection conn){
  Matrix<float> copy = buffer;

  // Processing functions
  copy = _preprocess(buffer);
  Matrix<float> correlMatrix = calcul_correl(copy);
  process_volume(correlMatrix, meanCorrelations);
  Matrix<RGB> mat = color_matrix(correlMatrix);

  // Send data
  string str = mat.toString();
  conn.send(str);
}
  \end{lstlisting}
  \begin{center}
    \textit{L'appel de la fonction \verb!process! ci-dessus exécute une série de fonctions de traitement de manière séquentielle.}
  \end{center}

  \begin{lstlisting}
    void ProcessMultiCorrel::process_volume(const Matrix<float>&
                                        correlMatrix,
                                        vector<float>&
                                        meanCorrelations){
  meanCorrelations = this->_mixLevel(correlMatrix);
}
  \end{lstlisting}
  \begin{center}
    \textit{Ci-dessus, la fonction appelée dans le corps de la fonction \verb!process!. Nous l'avons implémenté de sorte à altérer en son sein la valeur du vecteur des moyennes de corrélation passé par référence en paramètre.}
  \end{center}

\subsection{L'interface de configuration utilisateur}
\paragraph{}
Afin d'implémenter l'interface de configuration utilisateur précédemment abordée
nous avons ajouté à l'architecture du programme un dossier
\verb!GUI! (\textit{Graphic User Interface}) à la racine du programme.
Le sous-répertoire contenant les fichiers relatifs à l'implémentation de
l'interface de configuration se nomme \verb!settingWindow!.

\begin{figure}[h]
 \centering
 \includegraphics[scale=0.3]{umlSettingWindow.png}
 \caption{Schéma global du dispositif de VisualImpro}
 \label{schéma global}
\end{figure}

\paragraph{}
La classe principale de cette interface de configuration est la
classe \verb!settingWindow!. Celle-ci est tout simplement une fenêtre vide
qui permet d'afficher à l'intérieur d'elle même différentes parties.
Ces dernières sont les suivantes :
\begin{itemize}
 \item Paramètres de fonction de traitement.
 \item Paramètres du nombre d'entrées audio et analog.
 \item Choix des fichiers \textit{.wav}.
\end{itemize}
En plus de toutes ces parties, la fenêtre principale possède (check la doc)

\begin{figure}[h]
 \centering
 \includegraphics[scale=0.5]{umlBuilder.png}
 \caption{Schéma global du dispositif de VisualImpro}
 \label{schéma global}
\end{figure}

\paragraph{}
La fenêtre de configuration%AJOUTER

\subsection{Autres ajouts mineurs sur le programme}
\paragraph{}
Nous avons implémenté une nouvelle fonction de corrélation dédiée aux
tests : appelée \verb!CoeffRandom!, elle établit un coefficient de
corrélation de manière aléatoire. La généricité de l'implémentation
existante a rendu la tâche triviale, il nous a suffi d'écrire un
fichier d'en-tête \verb!CoeffRandom.hpp! et un fichier source
\verb!CoeffRandom.cpp! dans le dossier \verb!Coeff! contenant les
fonctions de calcul du coefficient de corrélation (dossier
\verb!process!). Cette fonction renvoie un flottant compris entre 0 et
1, comme les autres fonctions de corrélation. L'accomplissement de
cette tâche et la trivialité qu'il représente témoigne de la
généricité des fonctions de corrélation, et des fonctions de
traitement en général, qui possèdent désormais toutes plusieurs
versions alternatives.
